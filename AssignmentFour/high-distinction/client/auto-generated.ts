// Auto-generated PubSub Client (Node.js Compatible)
// Generated at: 2025-09-24T12:26:51.843Z
// Do not edit this file manually - it will be overwritten

import { z } from "zod/v4";

// Error type for unsupported Zod schema types
type NotSupportedErrorType<T extends string> = {
  __error: T;
  __note: "This Zod schema type is not yet supported by the code generator. Please add support for this type or use a different schema.";
};

export type ExampleEventEvent = {
  id: string;
  name: string;
  createdAt: Date;
};
export type HighDistinctionEventEvent = {
  id: string;
  message: string;
  createdAt: Date;
};
export type AnotherHighDistinctionEventEvent = {
  id: string;
  message: string;
  createdAt: Date;
};

// WebSocket interface that works in both Node.js and Browser
interface UniversalWebSocket {
  send(data: string): void;
  close(): void;
  readyState: number;
  onopen: ((event: any) => void) | null;
  onmessage: ((event: any) => void) | null;
  onclose: ((event: any) => void) | null;
  onerror: ((event: any) => void) | null;
}

export interface PubSubSubscription {
  id: string;
  event: string;
  unsubscribe(): Promise<void>;
}

export interface PubSubClientConfig {
  /** Maximum reconnection attempts (default: 5) */
  maxReconnectAttempts?: number;
  /** Reconnection delay in milliseconds (default: 1000) */
  reconnectDelay?: number;
  /** Enable debug logging (default: false) */
  debug?: boolean;
  /** Connection timeout in milliseconds (default: 5000) */
  connectionTimeout?: number;
}

export class PubSubClient {
  private ws: UniversalWebSocket | null = null;
  private subscriptions: Map<string, (data: any) => void> = new Map();
  private reconnectAttempts = 0;
  private config: Required<PubSubClientConfig>;
  private connectionPromise: Promise<void> | null = null;
  private isDestroyed = false;

  constructor(private serverUrl: string, config: PubSubClientConfig = {}) {
    this.config = {
      maxReconnectAttempts: 5,
      reconnectDelay: 1000,
      debug: false,
      connectionTimeout: 5000,
      ...config,
    };
  }

  private log(...args: any[]) {
    if (this.config.debug) {
      console.log('[PubSubClient]', ...args);
    }
  }

  private error(...args: any[]) {
    console.error('[PubSubClient]', ...args);
  }

  private async createWebSocket(url: string): Promise<UniversalWebSocket> {
    // In browser environment
    if (typeof window !== 'undefined') {
      return new WebSocket(url) as UniversalWebSocket;
    }

    // In Node.js environment
    try {
      const WebSocket = require('ws');
      return new WebSocket(url) as UniversalWebSocket;
    } catch (error) {
      throw new Error(
        'WebSocket not available. In Node.js, please install the "ws" package: npm install ws @types/ws'
      );
    }
  }

  /**
   * Connect to the PubSub server
   */
  async connect(): Promise<void> {
    if (this.connectionPromise) {
      return this.connectionPromise;
    }

    this.connectionPromise = new Promise(async (resolve, reject) => {
      const timeout = setTimeout(() => {
        reject(new Error('Connection timeout'));
      }, this.config.connectionTimeout);

      try {
        this.log('üîó Connecting to', this.serverUrl);
        this.ws = await this.createWebSocket(this.serverUrl);

        this.ws.onopen = () => {
          clearTimeout(timeout);
          this.log('‚úÖ Connected to PubSub server');
          this.reconnectAttempts = 0;
          resolve();
        };

        this.ws.onmessage = (event) => {
          const data = typeof event.data === 'string' ? event.data : event.data.toString();
          this.handleMessage(JSON.parse(data));
        };

        this.ws.onclose = () => {
          this.log('üîå Disconnected from PubSub server');
          this.connectionPromise = null;
          if (!this.isDestroyed) {
            this.attemptReconnect();
          }
        };

        this.ws.onerror = (error) => {
          clearTimeout(timeout);
          this.error('‚ùå WebSocket error:', error);
          this.connectionPromise = null;
          reject(error);
        };
      } catch (error) {
        clearTimeout(timeout);
        this.connectionPromise = null;
        reject(error);
      }
    });

    return this.connectionPromise;
  }

  private handleMessage(message: any) {
    this.log('üì® Received message:', message.type);

    switch (message.type) {
      case "event":
        const callback = this.subscriptions.get(message.subscriptionId);
        if (callback) {
          callback(message.data);
        }
        break;

      case "subscribed":
        this.log(`‚úÖ Subscribed to ${message.event} with ID: ${message.subscriptionId}`);
        break;

      case "unsubscribed":
        this.log(`‚ùå Unsubscribed from ${message.event} with ID: ${message.subscriptionId}`);
        break;

      case "published":
        this.log(`üì§ Published event: ${message.event}`);
        break;

      case "error":
        this.error("‚ùå Server error:", message.message, message.details);
        break;

      case "pong":
        this.log('üèì Pong received');
        break;

      default:
        this.log('üì® Unknown message type:', message.type);
    }
  }

  private attemptReconnect() {
    if (this.reconnectAttempts < this.config.maxReconnectAttempts && !this.isDestroyed) {
      this.reconnectAttempts++;
      this.log(
        `üîÑ Attempting to reconnect... (${this.reconnectAttempts}/${this.config.maxReconnectAttempts})`
      );

      setTimeout(() => {
        if (!this.isDestroyed) {
          this.connect().catch(this.error);
        }
      }, this.config.reconnectDelay * this.reconnectAttempts);
    } else if (!this.isDestroyed) {
      this.error("‚ùå Max reconnection attempts reached");
    }
  }

  /**
   * Subscribe to an event with type safety
   */
  async subscribe<T extends keyof EventTypes>(
    event: T,
    callback: (data: EventTypes[T]) => void
  ): Promise<PubSubSubscription> {
    await this.ensureConnected();

    const id = this.generateId();
    this.subscriptions.set(id, callback);

    this.send({
      type: "subscribe",
      event,
      id,
    });

    return {
      id,
      event: event as string,
      unsubscribe: () => this.unsubscribe(id),
    };
  }

  /**
   * Unsubscribe from an event
   */
  async unsubscribe(subscriptionId: string): Promise<void> {
    await this.ensureConnected();

    this.subscriptions.delete(subscriptionId);

    this.send({
      type: "unsubscribe",
      subscriptionId: subscriptionId,
    });
  }

  /**
   * Publish an event with type safety and validation
   */
  async publish<T extends keyof EventTypes>(
    event: T,
    data: EventTypes[T]
  ): Promise<void> {
    await this.ensureConnected();

    // Validate data against schema
    const schema = eventSchemas[event];
    if (schema) {
      try {
        schema.parse(data);
      } catch (error) {
        throw new Error(`Validation failed for event '${String(event)}': ${error}`);
      }
    }

    this.send({
      type: "publish",
      event,
      data,
    });
  }

  /**
   * Send a ping to the server
   */
  async ping(): Promise<void> {
    await this.ensureConnected();

    this.send({
      type: "ping",
    });
  }

  private async ensureConnected(): Promise<void> {
    if (!this.isConnected()) {
      await this.connect();
    }
  }

  private send(message: any) {
    if (this.ws && this.ws.readyState === 1) { // WebSocket.OPEN
      this.ws.send(JSON.stringify(message));
    } else {
      this.error("‚ùå WebSocket is not connected");
      throw new Error("WebSocket is not connected");
    }
  }

  private generateId(): string {
    // Use crypto.randomUUID if available, otherwise fallback
    if (typeof crypto !== 'undefined' && crypto.randomUUID) {
      return crypto.randomUUID();
    }

    // Fallback for older Node.js versions
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      const r = Math.random() * 16 | 0;
      const v = c === 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
    });
  }

  /**
   * Check if connected to the server
   */
  isConnected(): boolean {
    return this.ws !== null && this.ws.readyState === 1; // WebSocket.OPEN
  }

  /**
   * Get active subscriptions
   */
  getActiveSubscriptions(): string[] {
    return Array.from(this.subscriptions.keys());
  }

  /**
   * Get connection status
   */
  getStatus() {
    return {
      connected: this.isConnected(),
      reconnectAttempts: this.reconnectAttempts,
      activeSubscriptions: this.getActiveSubscriptions().length,
      serverUrl: this.serverUrl,
    };
  }

  /**
   * Disconnect and cleanup
   */
  disconnect() {
    this.isDestroyed = true;

    if (this.ws) {
      this.ws.close();
      this.ws = null;
    }

    this.subscriptions.clear();
    this.connectionPromise = null;
    this.log('üîå Disconnected');
  }


  /**
   * Subscribe to example.event events with full type safety
   */
  async subscribeExampleEvent(callback: (data: ExampleEventEvent) => void): Promise<PubSubSubscription> {
    return this.subscribe("example.event", callback);
  }

  /**
   * Publish example.event event with validation
   */
  async publishExampleEvent(data: ExampleEventEvent): Promise<void> {
    return this.publish("example.event", data);
  }

  /**
   * Subscribe to high_distinction.event events with full type safety
   */
  async subscribeHighDistinctionEvent(callback: (data: HighDistinctionEventEvent) => void): Promise<PubSubSubscription> {
    return this.subscribe("high_distinction.event", callback);
  }

  /**
   * Publish high_distinction.event event with validation
   */
  async publishHighDistinctionEvent(data: HighDistinctionEventEvent): Promise<void> {
    return this.publish("high_distinction.event", data);
  }

  /**
   * Subscribe to another_high_distinction.event events with full type safety
   */
  async subscribeAnotherHighDistinctionEvent(callback: (data: AnotherHighDistinctionEventEvent) => void): Promise<PubSubSubscription> {
    return this.subscribe("another_high_distinction.event", callback);
  }

  /**
   * Publish another_high_distinction.event event with validation
   */
  async publishAnotherHighDistinctionEvent(data: AnotherHighDistinctionEventEvent): Promise<void> {
    return this.publish("another_high_distinction.event", data);
  }
}

// Export schemas for external validation if needed
export const eventSchemas = {
  "example.event": z.object({
    id: z.string(),
    name: z.string(),
    createdAt: z.coerce.date(),
  }),
  "high_distinction.event": z.object({
    id: z.string(),
    message: z.string(),
    createdAt: z.coerce.date(),
  }),
  "another_high_distinction.event": z.object({
    id: z.string(),
    message: z.string(),
    createdAt: z.coerce.date(),
  }),
} as const;

// Export types
export type EventTypes = {
  "example.event": {
  id: string;
  name: string;
  createdAt: Date;
};
  "high_distinction.event": {
  id: string;
  message: string;
  createdAt: Date;
};
  "another_high_distinction.event": {
  id: string;
  message: string;
  createdAt: Date;
};
};

// Export default client
export default PubSubClient;
